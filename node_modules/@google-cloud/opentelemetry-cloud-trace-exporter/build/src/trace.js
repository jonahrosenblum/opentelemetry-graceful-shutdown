"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@opentelemetry/base");
const core_1 = require("@opentelemetry/core");
const google_auth_library_1 = require("google-auth-library");
const googleapis_1 = require("googleapis");
const transform_1 = require("./transform");
const OT_REQUEST_HEADER = 'x-opentelemetry-outgoing-request';
googleapis_1.google.options({ headers: { [OT_REQUEST_HEADER]: 1 } });
/**
 * Format and sends span information to Google Cloud Trace.
 */
class TraceExporter {
    constructor(options = {}) {
        this._logger = options.logger || new core_1.NoopLogger();
        this._auth = new google_auth_library_1.GoogleAuth({
            credentials: options.credentials,
            keyFile: options.keyFile,
            keyFilename: options.keyFilename,
            projectId: options.projectId,
            scopes: ['https://www.googleapis.com/auth/cloud-platform'],
        });
        // Start this async process as early as possible. It will be
        // awaited on the first export because constructors are synchronous
        this._projectId = this._auth.getProjectId().catch(err => {
            this._logger.error(err);
        });
    }
    /**
     * Publishes a list of spans to Google Cloud Trace.
     * @param spans The list of spans to transmit to Google Cloud Trace
     */
    async export(spans, resultCallback) {
        if (this._projectId instanceof Promise) {
            this._projectId = await this._projectId;
        }
        if (!this._projectId) {
            return resultCallback(base_1.ExportResult.FAILED_NOT_RETRYABLE);
        }
        this._logger.debug('Google Cloud Trace export');
        const authorizedSpans = await this._authorize(spans.map(transform_1.getReadableSpanTransformer(this._projectId)));
        if (!authorizedSpans) {
            return resultCallback(base_1.ExportResult.FAILED_NOT_RETRYABLE);
        }
        this._logger.debug('Google Cloud Trace got span authorization');
        try {
            await this._batchWriteSpans(authorizedSpans);
            resultCallback(base_1.ExportResult.SUCCESS);
        }
        catch (err) {
            this._logger.error(`Google Cloud Trace failed to export ${err}`);
            resultCallback(base_1.ExportResult.FAILED_RETRYABLE);
        }
    }
    shutdown() { }
    /**
     * Sends new spans to new or existing traces in the Google Cloud Trace format to the
     * service.
     * @param spans
     */
    _batchWriteSpans(spans) {
        this._logger.debug('Google Cloud Trace batch writing traces');
        return new Promise((resolve, reject) => {
            // @todo Consider to use gRPC call (BatchWriteSpansRequest) for sending
            // data to backend :
            // https://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.
            // cloudtrace.v2#google.devtools.cloudtrace.v2.TraceService
            TraceExporter._cloudTrace.projects.traces.batchWrite(spans, (err) => {
                if (err) {
                    err.message = `batchWriteSpans error: ${err.message}`;
                    this._logger.error(err.message);
                    reject(err);
                }
                else {
                    const successMsg = 'batchWriteSpans successfully';
                    this._logger.debug(successMsg);
                    resolve(successMsg);
                }
            });
        });
    }
    /**
     * Gets the Google Application Credentials from the environment variables,
     * authenticates the client and calls a method to send the spans data.
     * @param spans The spans to export
     */
    async _authorize(spans) {
        try {
            return {
                name: `projects/${this._projectId}`,
                resource: { spans },
                auth: await this._auth.getClient(),
            };
        }
        catch (err) {
            err.message = `authorize error: ${err.message}`;
            this._logger.error(err.message);
            return null;
        }
    }
}
exports.TraceExporter = TraceExporter;
TraceExporter._cloudTrace = googleapis_1.google.cloudtrace('v2');
//# sourceMappingURL=trace.js.map