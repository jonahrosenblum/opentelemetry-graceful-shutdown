"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObserverMetric = exports.ValueRecorderMetric = exports.CounterMetric = exports.Metric = void 0;
const BoundInstrument_1 = require("./BoundInstrument");
const ObserverResult_1 = require("./ObserverResult");
const types_1 = require("./export/types");
const Utils_1 = require("./Utils");
/** This is a SDK implementation of {@link Metric} interface. */
class Metric {
    constructor(_name, _options, _kind, resource) {
        this._name = _name;
        this._options = _options;
        this._kind = _kind;
        this.resource = resource;
        this._instruments = new Map();
        this._disabled = _options.disabled;
        this._valueType = _options.valueType;
        this._logger = _options.logger;
        this._descriptor = this._getMetricDescriptor();
    }
    /**
     * Returns an Instrument associated with specified Labels.
     * It is recommended to keep a reference to the Instrument instead of always
     * calling this method for each operation.
     * @param labels key-values pairs that are associated with a specific metric
     *     that you want to record.
     */
    bind(labels) {
        const hash = Utils_1.hashLabels(labels);
        if (this._instruments.has(hash))
            return this._instruments.get(hash);
        const instrument = this._makeInstrument(labels);
        this._instruments.set(hash, instrument);
        return instrument;
    }
    /**
     * Removes the Instrument from the metric, if it is present.
     * @param labels key-values pairs that are associated with a specific metric.
     */
    unbind(labels) {
        this._instruments.delete(Utils_1.hashLabels(labels));
    }
    /**
     * Clears all Instruments from the Metric.
     */
    clear() {
        this._instruments.clear();
    }
    getMetricRecord() {
        return Array.from(this._instruments.values()).map(instrument => ({
            descriptor: this._descriptor,
            labels: instrument.getLabels(),
            aggregator: instrument.getAggregator(),
            resource: this.resource,
        }));
    }
    _getMetricDescriptor() {
        return {
            name: this._name,
            description: this._options.description,
            unit: this._options.unit,
            metricKind: this._kind,
            valueType: this._valueType,
        };
    }
}
exports.Metric = Metric;
/** This is a SDK implementation of Counter Metric. */
class CounterMetric extends Metric {
    constructor(name, options, _batcher, resource) {
        super(name, options, types_1.MetricKind.COUNTER, resource);
        this._batcher = _batcher;
    }
    _makeInstrument(labels) {
        return new BoundInstrument_1.BoundCounter(labels, this._disabled, this._valueType, this._logger, 
        // @todo: consider to set to CounterSumAggregator always.
        this._batcher.aggregatorFor(this._descriptor));
    }
    /**
     * Adds the given value to the current value. Values cannot be negative.
     * @param value the value to add.
     * @param [labels = {}] key-values pairs that are associated with a specific
     *     metric that you want to record.
     */
    add(value, labels = {}) {
        this.bind(labels).add(value);
    }
}
exports.CounterMetric = CounterMetric;
class ValueRecorderMetric extends Metric {
    constructor(name, options, _batcher, resource) {
        super(name, options, types_1.MetricKind.VALUE_RECORDER, resource);
        this._batcher = _batcher;
        this._absolute = options.absolute !== undefined ? options.absolute : true; // Absolute default is true
    }
    _makeInstrument(labels) {
        return new BoundInstrument_1.BoundValueRecorder(labels, this._disabled, this._absolute, this._valueType, this._logger, this._batcher.aggregatorFor(this._descriptor));
    }
    record(value, labels = {}) {
        this.bind(labels).record(value);
    }
}
exports.ValueRecorderMetric = ValueRecorderMetric;
/** This is a SDK implementation of Observer Metric. */
class ObserverMetric extends Metric {
    constructor(name, options, _batcher, resource) {
        super(name, options, types_1.MetricKind.OBSERVER, resource);
        this._batcher = _batcher;
        this._observerResult = new ObserverResult_1.ObserverResult();
    }
    _makeInstrument(labels) {
        return new BoundInstrument_1.BoundObserver(labels, this._disabled, this._valueType, this._logger, this._batcher.aggregatorFor(this._descriptor));
    }
    getMetricRecord() {
        this._observerResult.callbackObservers.forEach((callback, labels) => {
            const instrument = this.bind(labels);
            instrument.update(callback());
        });
        return super.getMetricRecord();
    }
    /**
     * Sets a callback where user can observe value for certain labels
     * @param callback
     */
    setCallback(callback) {
        callback(this._observerResult);
        this._observerResult.observers.forEach((observer, labels) => {
            observer.subscribe(value => {
                const instrument = this.bind(labels);
                instrument.update(value);
            });
        });
    }
}
exports.ObserverMetric = ObserverMetric;
//# sourceMappingURL=Metric.js.map