import { ValueType, HrTime, Labels } from '@opentelemetry/api';
import { ExportResult } from '@opentelemetry/core';
import { Resource } from '@opentelemetry/resources';
/** The kind of metric. */
export declare enum MetricKind {
    COUNTER = 0,
    UP_DOWN_COUNTER = 1,
    VALUE_RECORDER = 2,
    OBSERVER = 3,
    SUM_OBSERVER = 4,
    UP_DOWN_SUM_OBSERVER = 5,
    VALUE_OBSERVER = 6
}
/** Sum returns an aggregated sum. */
export declare type Sum = number;
/** LastValue returns last value. */
export declare type LastValue = number;
export interface Distribution {
    min: number;
    max: number;
    count: number;
    sum: number;
}
export interface Histogram {
    /**
     * Buckets are implemented using two different array:
     *  - boundaries contains every boundary (which are upper boundary for each slice)
     *  - counts contains count of event for each slice
     *
     * Note that we'll always have n+1 (where n is the number of boundaries) slice
     * because we need to count event that are above the highest boundary. This is the
     * reason why it's not implement using array of object, because the last slice
     * dont have any boundary.
     *
     * Example if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]
     *  with the boundaries [ 10, 20, 30 ], we will have the following state:
     *
     * buckets: {
     *	boundaries: [10, 20, 30],
     *	counts: [3, 3, 2, 1],
     * }
     */
    buckets: {
        boundaries: number[];
        counts: number[];
    };
    sum: number;
    count: number;
}
export interface MetricRecord {
    readonly descriptor: MetricDescriptor;
    readonly labels: Labels;
    readonly aggregator: Aggregator;
    readonly resource: Resource;
}
export interface MetricDescriptor {
    readonly name: string;
    readonly description: string;
    readonly unit: string;
    readonly metricKind: MetricKind;
    readonly valueType: ValueType;
}
/**
 * Base interface that represents a metric exporter
 */
export interface MetricExporter {
    /** Exports the list of a given {@link MetricRecord} */
    export(metrics: MetricRecord[], resultCallback: (result: ExportResult) => void): void;
    /** Stops the exporter. */
    shutdown(): void;
}
/**
 * Base interface for aggregators. Aggregators are responsible for holding
 * aggregated values and taking a snapshot of these values upon export.
 */
export interface Aggregator {
    /** Updates the current with the new value. */
    update(value: number): void;
    /** Returns snapshot of the current point (value with timestamp). */
    toPoint(): Point;
}
export interface Point {
    value: Sum | LastValue | Distribution | Histogram;
    timestamp: HrTime;
}
//# sourceMappingURL=types.d.ts.map