import * as api from '@opentelemetry/api';
import { Resource } from '@opentelemetry/resources';
import { BoundCounter, BaseBoundInstrument, BoundValueRecorder, BoundObserver } from './BoundInstrument';
import { MetricOptions } from './types';
import { MetricKind, MetricDescriptor, MetricRecord } from './export/types';
import { Batcher } from './export/Batcher';
/** This is a SDK implementation of {@link Metric} interface. */
export declare abstract class Metric<T extends BaseBoundInstrument> implements api.UnboundMetric<T> {
    private readonly _name;
    private readonly _options;
    private readonly _kind;
    readonly resource: Resource;
    protected readonly _disabled: boolean;
    protected readonly _valueType: api.ValueType;
    protected readonly _logger: api.Logger;
    protected readonly _descriptor: MetricDescriptor;
    private readonly _instruments;
    constructor(_name: string, _options: MetricOptions, _kind: MetricKind, resource: Resource);
    /**
     * Returns an Instrument associated with specified Labels.
     * It is recommended to keep a reference to the Instrument instead of always
     * calling this method for each operation.
     * @param labels key-values pairs that are associated with a specific metric
     *     that you want to record.
     */
    bind(labels: api.Labels): T;
    /**
     * Removes the Instrument from the metric, if it is present.
     * @param labels key-values pairs that are associated with a specific metric.
     */
    unbind(labels: api.Labels): void;
    /**
     * Clears all Instruments from the Metric.
     */
    clear(): void;
    getMetricRecord(): MetricRecord[];
    private _getMetricDescriptor;
    protected abstract _makeInstrument(labels: api.Labels): T;
}
/** This is a SDK implementation of Counter Metric. */
export declare class CounterMetric extends Metric<BoundCounter> implements api.Counter {
    private readonly _batcher;
    constructor(name: string, options: MetricOptions, _batcher: Batcher, resource: Resource);
    protected _makeInstrument(labels: api.Labels): BoundCounter;
    /**
     * Adds the given value to the current value. Values cannot be negative.
     * @param value the value to add.
     * @param [labels = {}] key-values pairs that are associated with a specific
     *     metric that you want to record.
     */
    add(value: number, labels?: api.Labels): void;
}
export declare class ValueRecorderMetric extends Metric<BoundValueRecorder> implements api.ValueRecorder {
    private readonly _batcher;
    protected readonly _absolute: boolean;
    constructor(name: string, options: MetricOptions, _batcher: Batcher, resource: Resource);
    protected _makeInstrument(labels: api.Labels): BoundValueRecorder;
    record(value: number, labels?: api.Labels): void;
}
/** This is a SDK implementation of Observer Metric. */
export declare class ObserverMetric extends Metric<BoundObserver> implements api.Observer {
    private readonly _batcher;
    private _observerResult;
    constructor(name: string, options: MetricOptions, _batcher: Batcher, resource: Resource);
    protected _makeInstrument(labels: api.Labels): BoundObserver;
    getMetricRecord(): MetricRecord[];
    /**
     * Sets a callback where user can observe value for certain labels
     * @param callback
     */
    setCallback(callback: (observerResult: api.ObserverResult) => void): void;
}
//# sourceMappingURL=Metric.d.ts.map